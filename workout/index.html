<!DOCTYPE html>
<html>
  <head>
    <title>Rower Status Display</title>
    <meta name="viewport" width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0>
    <style> body {padding: 0; margin: 0;} </style>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.2.0/lib/p5.js"></script>

<meta property="og:title" content="Rower Status Display">
<meta property="og:site_name" content="Open source rower monitor">
<meta property="og:url" content="https://trmm.net/Rower/">
<meta property="og:description" content="Interface to open source water-rower monitoring hardware">
<meta property="og:image" content="https://live.staticflickr.com/4472/37526022032_d7afc7358d.jpg">
  </head>
  <body>
<form id="uploadForm">
<input id="fileDownload" type="button" value="Download CSV" onclick="download()"/>
</form>

<div id="sketch-holder">
      <!-- Our sketch will go here! -->
</div>

<script>
function download()
{
	let csv = "";
	csv += "time,stroke_usec,tick_usec,force,power,spm\n";
	for(var d of data)
		csv += d.join(",") + "\n";
	
	var element = document.createElement('a');
	csv = encodeURIComponent(csv);
	element.setAttribute('href', 'data:text/plain;charset=utf-8,' + csv);
	element.setAttribute('download', "workout.csv");
	element.style.display = 'none';
	document.body.appendChild(element);
	element.click();
	document.body.removeChild(element);
}

/*
 * Make a websocket connection to the rower and then draw the data
 */

let new_data = null;
let data = [];
let total_work = 0;
let last_work = 0;
let total_strokes = 0;

function setup()
{
	let canvas = createCanvas(windowWidth-10, windowHeight-10);

	// Move the canvas so itâ€™s inside our <div id="sketch-holder">.
	canvas.parent('sketch-holder');

	background(0);

	// connect to the rower's websocket and append any new data as it comes in
	let connection = new WebSocket('ws://' + location.hostname + ':81/', ['arduino']);
	//let connection = new WebSocket('ws://192.168.178.50:81/', ['arduino']);
	connection.onopen = function () { connection.send('Connect ' + new Date()); };
	connection.onerror = function (error) { console.log('WebSocket Error ', error);};
	connection.onmessage = function (e) {
		console.log('Server: ', e.data);
		if (e.data == "Connected")
			return;

		new_data = e.data.split(',');

		// fix up the power and spm colun
		new_data[3] /= 500000.0;
		new_data[4] /= 500000.0;
		new_data[5] /= 10.0;

		// fake out the last power measurement, just in case
		if (new_data[1] == 0)
		{
			last_work = int(total_work);
			new_data[4] = int(total_work);
			total_strokes++;
		}
	};
}

let last_sx = 0;
let last_sy = 0;

function draw_stroke(d,w,h)
{
	// if the time stamp on the new data is 0, then this is
	// the start of a new stroke.  decay the old chart a little bit
	if (d[1] == 0) {
		noStroke();
		fill(0, 0, 0, 35);
		rect(0, 0, w, h);
		last_sx = 0;
		last_sy = 0;

		strokeWeight(1);
		noFill();
		stroke(50);
		line(0,h/2, w, h/2);
		line(0,h*3/4, w, h*3/4);
		line(0,h/4, w, h/4);
	}

	// don't draw for the return stroke
	if (d[2] < 0)
		return;

	strokeWeight(2);
	stroke(0,255,0);
	let sx = d[1] * w / 2e6; // up to 2 seconds of display
	let sy = d[3] * h / 65.0; // "drag-force" goes up to around 60kg

	if (sx > w)
		sx = w;
	if (sy > h)
		sy = h;

	line(last_sx, h - last_sy, sx, h - sy);
	last_sx = sx;
	last_sy = sy;

	// need a scale factor for the work done on this stroke
	total_work = d[4];

	noStroke();
	fill(0);
	rect(w-200,0,200,50);
	fill(0,255,0);
	textAlign(RIGHT, BOTTOM);
	textSize(50);
	//text(int(d[3] / 1e3), w, 50);
	text(int(total_work), w, 50);
}

function draw_strip(d,w,h,index,max,scale_step)
{
	let now = d[0];
	let start = data[0][0];
	let delta = now - start;
	let sx = w / (delta+1);
	let sy = h / max;

	fill(0);
	rect(0,0,w,h);

	noFill();
	stroke(50);
	strokeWeight(1);
	for(let v = 0 ; v < max ; v += scale_step)
		line(0, h -  v*sy, w, h -  v*sy);

	for(let t = 15e6 ; t < delta ; t += 15 * 1e6)
		line(t*sx, 0, t*sx, h);
	stroke(100);
	for(let t = 60e6 ; t < delta ; t += 60 * 1e6)
		line(t*sx, 0, t*sx, h);

	stroke(0xff);
	strokeWeight(2);
	beginShape();

	for(let p of data)
	{
		if (p[1] != 0)
			continue;
		let x = (p[0] - start) * sx;
		let y = p[index] * sy;
		vertex(x, h - y);
	}

	endShape();
}

function draw()
{
	// retrieve the most recent data
	if (!new_data)
		return;
	data.push(new_data);

	push();
	translate(0,0);
	draw_stroke(new_data, 400, 400);
	pop();

	// draw the strokes per minute
	push();
	translate(400,0);
	draw_strip(new_data, width-400, 200, 5, 60, 10);

	fill(0xff);
	noStroke();
	textSize(50);
	textAlign(RIGHT, BOTTOM);
	text(new_data[5], width-400, 100);
	textAlign(LEFT, BOTTOM);
	text(total_strokes, 0, 100);

	pop();

	// draw the power per minute
	push();
	translate(400,200);
	draw_strip(new_data, width-400, 200, 4, 500, 100);

	fill(0xff);
	noStroke();
	textSize(50);
	textAlign(RIGHT, BOTTOM);
	text(int(last_work), width-400, 100);

	textAlign(LEFT, BOTTOM);
	let total_time = int((new_data[0] - data[0][0]) / 1000);
	let total_ms = total_time % 1000;
	total_time = int(total_time / 1000);
	let total_sec = total_time % 60;
	total_time = int(total_time / 60);
	let total_min = total_time;
	
	if (total_sec == 0)
		total_sec = "00";
	else
	if (total_sec < 10)
		total_sec = "0" + total_sec;

	if (total_ms == 0)
		total_ms = "000";
	else
	if (total_ms < 10)
		total_ms = "00" + total_ms;
	if (total_ms < 100)
		total_ms = "0" + total_ms;

	let time_str = total_min + ":" + total_sec + "." + total_ms;
	text(time_str, 0, 100);

	pop();

	new_data = null;
}
</script>
  </body>
</html>
