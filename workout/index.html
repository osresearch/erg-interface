<!DOCTYPE html>
<html>
  <head>
    <title>Rower Status Display</title>
    <meta name="viewport" width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0>
    <style> body {padding: 0; margin: 0;} </style>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.2.0/lib/p5.js"></script>

<meta property="og:title" content="Rower Status Display">
<meta property="og:site_name" content="Open source rower monitor">
<meta property="og:url" content="https://trmm.net/Rower/">
<meta property="og:description" content="Interface to open source water-rower monitoring hardware">
<meta property="og:image" content="https://live.staticflickr.com/4472/37526022032_d7afc7358d.jpg">
  </head>
  <body>
<form id="uploadForm">
<input id="fileDownload" type="button" value="Download CSV" onclick="download()"/>
</form>

<div id="sketch-holder">
      <!-- Our sketch will go here! -->
</div>

<script>
function download()
{
	let csv = "";
	csv += "time,stroke_usec,tick_usec,force,power,spm\n";
	for(var d of data)
		csv += d.join(",") + "\n";
	
	var element = document.createElement('a');
	csv = encodeURIComponent(csv);
	element.setAttribute('href', 'data:text/plain;charset=utf-8,' + csv);
	element.setAttribute('download', "workout.csv");
	element.style.display = 'none';
	document.body.appendChild(element);
	element.click();
	document.body.removeChild(element);
}

/*
 * Make a websocket connection to the rower and then draw the data
 */

let new_data = null;
let data = [];
let total_work = 0;
let last_work = 0;
let total_strokes = 0;
let inst_power_total = 0;

function setup()
{
	let canvas = createCanvas(windowWidth-10, windowHeight-10);

	// Move the canvas so itâ€™s inside our <div id="sketch-holder">.
	canvas.parent('sketch-holder');

	background(0);

	// connect to the rower's websocket and append any new data as it comes in
	let host = location.hostname;
	if (!host)
		host = "192.168.178.51";
	let connection = new WebSocket('ws://' + host + ':81/', ['arduino']);
	connection.onopen = function () { connection.send('Connect ' + new Date()); };
	connection.onerror = function (error) { console.log('WebSocket Error ', error);};
	connection.onmessage = function (e) {
		console.log('Server: ', e.data);
		if (e.data == "Connected")
			return;

		new_data = e.data.split(',');

		// fix up the power and spm colun
		new_data[3] /= 500000.0;
		new_data[4] /= 500000.0;
		new_data[5] /= 10.0;

		// track total power for the workout
		if (new_data[2] > 0)
			inst_power_total += new_data[3];

		// fake out the last power measurement, just in case
		if (new_data[1] == 0)
		{
			last_work = int(total_work);
			new_data[4] = int(total_work);
			total_strokes++;
		}
	};
}

let last_sx = 0;
let last_sy = 0;

function draw_stroke(d,w,h)
{
	// if the time stamp on the new data is 0, then this is
	// the start of a new stroke.  decay the old chart a little bit
	if (d[1] == 0) {
		noStroke();
		fill(0, 0, 0, 35);
		rect(0, 0, w, h);
		last_sx = 0;
		last_sy = 0;

		strokeWeight(1);
		noFill();
		stroke(50);
		line(0,h/2, w, h/2);
		line(0,h*3/4, w, h*3/4);
		line(0,h/4, w, h/4);
	}

	// don't draw for the return stroke
	if (d[2] < 0)
		return;

	strokeWeight(2);
	stroke(0,255,0);
	let sx = d[1] * w / 1e6; // 1 second of display for the pull curve
	let sy = d[3] * h / 65.0; // "drag-force" goes up to around 60kg

	if (sx > w)
		sx = w;
	if (sy > h)
		sy = h;

	line(last_sx, h - last_sy, sx, h - sy);
	last_sx = sx;
	last_sy = sy;

	// need a scale factor for the work done on this stroke
	total_work = d[4];

	noStroke();
	fill(0);
	rect(w-200,0,200,50);
	fill(0,255,0);
	textAlign(RIGHT, BOTTOM);
	textSize(50);
	//text(int(d[3] / 1e3), w, 50);
	text(int(total_work), w, 50);
}

function draw_strip(d,w,h,index,max,scale_step)
{
	let now = d[0];
	let start = data[0][0];
	let delta = now - start;
	let sx = w / (delta+1);
	let sy = h / max;
	let total = 0;
	let samples = 0;

	fill(0);
	rect(0,0,w,h);

	noFill();
	stroke(50);
	strokeWeight(1);
	for(let v = 0 ; v < max ; v += scale_step)
		line(0, h -  v*sy, w, h -  v*sy);

	for(let t = 15e6 ; t < delta ; t += 15 * 1e6)
		line(t*sx, 0, t*sx, h);
	stroke(100);
	for(let t = 60e6 ; t < delta ; t += 60 * 1e6)
		line(t*sx, 0, t*sx, h);

	stroke(0xff);
	strokeWeight(2);
	let drawing = 0;

	for(let p of data)
	{
		if (p[2] == 0)
		{
			if (drawing)
				endShape();
			drawing = 0;
			continue;
		}

		if (p[1] != 0)
			continue;

		if (!drawing)
			beginShape();
		drawing = 1;

		let v = p[index];
		total += v;
		samples++;

		let x = (p[0] - start) * sx;
		let y = v * sy;
		vertex(x, h - y);
	}

	if (drawing)
		endShape();

	return [total,delta,samples];
}

function draw()
{
	// retrieve the most recent data
	if (!new_data)
		return;
	data.push(new_data);

	push();
	translate(0,0);
	draw_stroke(new_data, 400, 400);
	pop();

	// draw the strokes per minute
	let last_spm = new_data[5];

	push();
	translate(400,0);
	let [spm_sum,spm_dt,spm_samples] =
		draw_strip(new_data, width-400, 200, 5, 60, 10);

	fill(0xff);
	noStroke();
	textSize(50);
	textAlign(RIGHT, BOTTOM);
	text(last_spm, width-400, 100);

	pop();

	// draw the power per minute
	push();
	translate(400,200);
	let [power_total,power_dt,power_samples] =
		draw_strip(new_data, width-400, 200, 4, 500, 100);

	fill(0xff);
	noStroke();
	textSize(50);
	textAlign(RIGHT, BOTTOM);
	text(int(last_work), width-400, 100);

	pop();

	// count the number of positive ticks to estimate distance
	let ticks = 0;
	for(let d of data)
	{
		if (d[2] > 0)
			ticks++;
	}

	const ticks_to_m = 1.18;
	let distance = (ticks * ticks_to_m).toFixed(1);

	// draw the summary stats at the bottom in a large font
	push();
	translate(0,400);

	fill(0);
	noStroke();
	rect(0,0, width, 200);

	fill(0xff);
	textSize(60);
	textAlign(RIGHT, BOTTOM);

	// average strokes per minute (scaled from microseconds)
	let spm_avg = "???"
	if (spm_dt != 0)
		spm_avg = (spm_samples / (spm_dt / 60e6)).toFixed(1);

	// total strokes @ avg cadence
	text(spm_samples + " strokes @ " + spm_avg + "/min", width, 70);

	// total power and average per stroke
	let power_avg = "???";
	if (power_samples != 0)
		power_avg = (power_total / power_samples).toFixed(0);
	text(inst_power_total.toFixed(2) + " power @ " + power_avg + "/stroke", width, 130);

	// work/minute for "pace"
	text((last_work * last_spm).toFixed(0) + " work/min",  width, 190);

	// workout time
	let total_time = int(power_dt / 1000);
	let total_ms = total_time % 1000;
	total_time = int(total_time / 1000);
	let total_sec = total_time % 60;
	total_time = int(total_time / 60);
	let total_min = total_time;
	
	if (total_sec == 0)
		total_sec = "00";
	else
	if (total_sec < 10)
		total_sec = "0" + total_sec;

	if (total_ms == 0)
		total_ms = "000";
	else
	if (total_ms < 10)
		total_ms = "00" + total_ms;
	if (total_ms < 100)
		total_ms = "0" + total_ms;

	//let time_str = total_min + ":" + total_sec + "." + total_ms;
	let time_str = total_min + ":" + total_sec + " / " + distance;

	textSize(100);
	textAlign(LEFT, BOTTOM);
	text(time_str, 0, 120);

	pop();

	new_data = null;
}
</script>
  </body>
</html>
